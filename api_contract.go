/*
 * MicrovisionChain API Document
 *
 * API definition for MicrovisionChain provided apis
 *
 * API version: 3.0.9
 * Contact: heqiming@metasv.com
 */

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package mvcapi

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// ContractApiService ContractApi service
type ContractApiService service

type ApiContractFtAddressAddressBalanceConfirmedGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
	codeHash   *string
	genesis    *string
}

func (r ApiContractFtAddressAddressBalanceConfirmedGetRequest) CodeHash(codeHash string) ApiContractFtAddressAddressBalanceConfirmedGetRequest {
	r.codeHash = &codeHash
	return r
}
func (r ApiContractFtAddressAddressBalanceConfirmedGetRequest) Genesis(genesis string) ApiContractFtAddressAddressBalanceConfirmedGetRequest {
	r.genesis = &genesis
	return r
}

func (r ApiContractFtAddressAddressBalanceConfirmedGetRequest) Execute() (int64, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractFtAddressAddressBalanceConfirmedGetExecute(r)
}

/*
 * ContractFtAddressAddressBalanceConfirmedGet Get all contract token balances for specific address ignoring all unconfirmed txs.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address the requested address
 * @return ApiContractFtAddressAddressBalanceConfirmedGetRequest
 */
func (a *ContractApiService) ContractFtAddressAddressBalanceConfirmedGet(ctx _context.Context, address string) ApiContractFtAddressAddressBalanceConfirmedGetRequest {
	return ApiContractFtAddressAddressBalanceConfirmedGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
	}
}

/*
 * Execute executes the request
 * @return int64
 */
func (a *ContractApiService) ContractFtAddressAddressBalanceConfirmedGetExecute(r ApiContractFtAddressAddressBalanceConfirmedGetRequest) (int64, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractFtAddressAddressBalanceConfirmedGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/ft/address/{address}/balance/confirmed"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.codeHash == nil {
		executionError.error = "codeHash is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.genesis == nil {
		executionError.error = "genesis is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("codeHash", parameterToString(*r.codeHash, ""))
	localVarQueryParams.Add("genesis", parameterToString(*r.genesis, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractFtAddressAddressBalanceGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
	codeHash   *string
	genesis    *string
}

func (r ApiContractFtAddressAddressBalanceGetRequest) CodeHash(codeHash string) ApiContractFtAddressAddressBalanceGetRequest {
	r.codeHash = &codeHash
	return r
}
func (r ApiContractFtAddressAddressBalanceGetRequest) Genesis(genesis string) ApiContractFtAddressAddressBalanceGetRequest {
	r.genesis = &genesis
	return r
}

func (r ApiContractFtAddressAddressBalanceGetRequest) Execute() ([]ContractFtBalance, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractFtAddressAddressBalanceGetExecute(r)
}

/*
 * ContractFtAddressAddressBalanceGet Get all contract token balances for specific address.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address the requested address
 * @return ApiContractFtAddressAddressBalanceGetRequest
 */
func (a *ContractApiService) ContractFtAddressAddressBalanceGet(ctx _context.Context, address string) ApiContractFtAddressAddressBalanceGetRequest {
	return ApiContractFtAddressAddressBalanceGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
	}
}

/*
 * Execute executes the request
 * @return []ContractFtBalance
 */
func (a *ContractApiService) ContractFtAddressAddressBalanceGetExecute(r ApiContractFtAddressAddressBalanceGetRequest) ([]ContractFtBalance, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractFtBalance
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractFtAddressAddressBalanceGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/ft/address/{address}/balance"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.codeHash != nil {
		localVarQueryParams.Add("codeHash", parameterToString(*r.codeHash, ""))
	}
	if r.genesis != nil {
		localVarQueryParams.Add("genesis", parameterToString(*r.genesis, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractFtAddressAddressCodeHashGenesisTxGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
	codeHash   string
	genesis    string
	flag       *string
}

func (r ApiContractFtAddressAddressCodeHashGenesisTxGetRequest) Flag(flag string) ApiContractFtAddressAddressCodeHashGenesisTxGetRequest {
	r.flag = &flag
	return r
}

func (r ApiContractFtAddressAddressCodeHashGenesisTxGetRequest) Execute() ([]ContractFtAddressTx, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractFtAddressAddressCodeHashGenesisTxGetExecute(r)
}

/*
 * ContractFtAddressAddressCodeHashGenesisTxGet Get all contract token balances for specific address.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address the requested address
 * @param codeHash Filter by contract code hash
 * @param genesis Filter by contract genesis
 * @return ApiContractFtAddressAddressCodeHashGenesisTxGetRequest
 */
func (a *ContractApiService) ContractFtAddressAddressCodeHashGenesisTxGet(ctx _context.Context, address string, codeHash string, genesis string) ApiContractFtAddressAddressCodeHashGenesisTxGetRequest {
	return ApiContractFtAddressAddressCodeHashGenesisTxGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
		codeHash:   codeHash,
		genesis:    genesis,
	}
}

/*
 * Execute executes the request
 * @return []ContractFtAddressTx
 */
func (a *ContractApiService) ContractFtAddressAddressCodeHashGenesisTxGetExecute(r ApiContractFtAddressAddressCodeHashGenesisTxGetRequest) ([]ContractFtAddressTx, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractFtAddressTx
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractFtAddressAddressCodeHashGenesisTxGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/ft/address/{address}/{codeHash}/{genesis}/tx"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"codeHash"+"}", _neturl.PathEscape(parameterToString(r.codeHash, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"genesis"+"}", _neturl.PathEscape(parameterToString(r.genesis, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.flag != nil {
		localVarQueryParams.Add("flag", parameterToString(*r.flag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractFtAddressAddressUtxoGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
	codeHash   *string
	genesis    *string
	flag       *string
}

func (r ApiContractFtAddressAddressUtxoGetRequest) CodeHash(codeHash string) ApiContractFtAddressAddressUtxoGetRequest {
	r.codeHash = &codeHash
	return r
}
func (r ApiContractFtAddressAddressUtxoGetRequest) Genesis(genesis string) ApiContractFtAddressAddressUtxoGetRequest {
	r.genesis = &genesis
	return r
}
func (r ApiContractFtAddressAddressUtxoGetRequest) Flag(flag string) ApiContractFtAddressAddressUtxoGetRequest {
	r.flag = &flag
	return r
}

func (r ApiContractFtAddressAddressUtxoGetRequest) Execute() ([]ContractFtUtxo, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractFtAddressAddressUtxoGetExecute(r)
}

/*
 * ContractFtAddressAddressUtxoGet Get all contract token utxos for specific address.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address the requested address
 * @return ApiContractFtAddressAddressUtxoGetRequest
 */
func (a *ContractApiService) ContractFtAddressAddressUtxoGet(ctx _context.Context, address string) ApiContractFtAddressAddressUtxoGetRequest {
	return ApiContractFtAddressAddressUtxoGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
	}
}

/*
 * Execute executes the request
 * @return []ContractFtUtxo
 */
func (a *ContractApiService) ContractFtAddressAddressUtxoGetExecute(r ApiContractFtAddressAddressUtxoGetRequest) ([]ContractFtUtxo, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractFtUtxo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractFtAddressAddressUtxoGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/ft/address/{address}/utxo"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.codeHash != nil {
		localVarQueryParams.Add("codeHash", parameterToString(*r.codeHash, ""))
	}
	if r.genesis != nil {
		localVarQueryParams.Add("genesis", parameterToString(*r.genesis, ""))
	}
	if r.flag != nil {
		localVarQueryParams.Add("flag", parameterToString(*r.flag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractFtGenesisCodeHashGenesisCirculationGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	codeHash   string
	genesis    string
}

func (r ApiContractFtGenesisCodeHashGenesisCirculationGetRequest) Execute() (ContractFtGenesisCirculation, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractFtGenesisCodeHashGenesisCirculationGetExecute(r)
}

/*
 * ContractFtGenesisCodeHashGenesisCirculationGet Get all sum of circulation ft token utxos by codeHash and genesisId(10min cached).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param codeHash Code hash of the token.
 * @param genesis Contract genesis
 * @return ApiContractFtGenesisCodeHashGenesisCirculationGetRequest
 */
func (a *ContractApiService) ContractFtGenesisCodeHashGenesisCirculationGet(ctx _context.Context, codeHash string, genesis string) ApiContractFtGenesisCodeHashGenesisCirculationGetRequest {
	return ApiContractFtGenesisCodeHashGenesisCirculationGetRequest{
		ApiService: a,
		ctx:        ctx,
		codeHash:   codeHash,
		genesis:    genesis,
	}
}

/*
 * Execute executes the request
 * @return ContractFtGenesisCirculation
 */
func (a *ContractApiService) ContractFtGenesisCodeHashGenesisCirculationGetExecute(r ApiContractFtGenesisCodeHashGenesisCirculationGetRequest) (ContractFtGenesisCirculation, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  ContractFtGenesisCirculation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractFtGenesisCodeHashGenesisCirculationGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/ft/genesis/{codeHash}/{genesis}/circulation"
	localVarPath = strings.Replace(localVarPath, "{"+"codeHash"+"}", _neturl.PathEscape(parameterToString(r.codeHash, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"genesis"+"}", _neturl.PathEscape(parameterToString(r.genesis, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractNftAddressAddressCountConfirmedGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
	codeHash   *string
	genesis    *string
}

func (r ApiContractNftAddressAddressCountConfirmedGetRequest) CodeHash(codeHash string) ApiContractNftAddressAddressCountConfirmedGetRequest {
	r.codeHash = &codeHash
	return r
}
func (r ApiContractNftAddressAddressCountConfirmedGetRequest) Genesis(genesis string) ApiContractNftAddressAddressCountConfirmedGetRequest {
	r.genesis = &genesis
	return r
}

func (r ApiContractNftAddressAddressCountConfirmedGetRequest) Execute() (int32, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractNftAddressAddressCountConfirmedGetExecute(r)
}

/*
 * ContractNftAddressAddressCountConfirmedGet Get confirmed utxo count for specific nft(ignore all unconfirmed txs).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address the requested address
 * @return ApiContractNftAddressAddressCountConfirmedGetRequest
 */
func (a *ContractApiService) ContractNftAddressAddressCountConfirmedGet(ctx _context.Context, address string) ApiContractNftAddressAddressCountConfirmedGetRequest {
	return ApiContractNftAddressAddressCountConfirmedGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
	}
}

/*
 * Execute executes the request
 * @return int32
 */
func (a *ContractApiService) ContractNftAddressAddressCountConfirmedGetExecute(r ApiContractNftAddressAddressCountConfirmedGetRequest) (int32, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  int32
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractNftAddressAddressCountConfirmedGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/nft/address/{address}/count/confirmed"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.codeHash == nil {
		executionError.error = "codeHash is required and must be specified"
		return localVarReturnValue, nil, executionError
	}
	if r.genesis == nil {
		executionError.error = "genesis is required and must be specified"
		return localVarReturnValue, nil, executionError
	}

	localVarQueryParams.Add("codeHash", parameterToString(*r.codeHash, ""))
	localVarQueryParams.Add("genesis", parameterToString(*r.genesis, ""))
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractNftAddressAddressSummaryGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
}

func (r ApiContractNftAddressAddressSummaryGetRequest) Execute() ([]ContractNftAddressSummary, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractNftAddressAddressSummaryGetExecute(r)
}

/*
 * ContractNftAddressAddressSummaryGet Get nft summary(NFT count group by genesis) for address.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address the requested address
 * @return ApiContractNftAddressAddressSummaryGetRequest
 */
func (a *ContractApiService) ContractNftAddressAddressSummaryGet(ctx _context.Context, address string) ApiContractNftAddressAddressSummaryGetRequest {
	return ApiContractNftAddressAddressSummaryGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
	}
}

/*
 * Execute executes the request
 * @return []ContractNftAddressSummary
 */
func (a *ContractApiService) ContractNftAddressAddressSummaryGetExecute(r ApiContractNftAddressAddressSummaryGetRequest) ([]ContractNftAddressSummary, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractNftAddressSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractNftAddressAddressSummaryGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/nft/address/{address}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractNftAddressAddressUtxoGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
	codeHash   *string
	genesis    *string
	limit      *int32
	flag       *string
}

func (r ApiContractNftAddressAddressUtxoGetRequest) CodeHash(codeHash string) ApiContractNftAddressAddressUtxoGetRequest {
	r.codeHash = &codeHash
	return r
}
func (r ApiContractNftAddressAddressUtxoGetRequest) Genesis(genesis string) ApiContractNftAddressAddressUtxoGetRequest {
	r.genesis = &genesis
	return r
}
func (r ApiContractNftAddressAddressUtxoGetRequest) Limit(limit int32) ApiContractNftAddressAddressUtxoGetRequest {
	r.limit = &limit
	return r
}
func (r ApiContractNftAddressAddressUtxoGetRequest) Flag(flag string) ApiContractNftAddressAddressUtxoGetRequest {
	r.flag = &flag
	return r
}

func (r ApiContractNftAddressAddressUtxoGetRequest) Execute() ([]ContractNftUtxo, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractNftAddressAddressUtxoGetExecute(r)
}

/*
 * ContractNftAddressAddressUtxoGet Get all contract nft token utxos for specific address.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address the requested address
 * @return ApiContractNftAddressAddressUtxoGetRequest
 */
func (a *ContractApiService) ContractNftAddressAddressUtxoGet(ctx _context.Context, address string) ApiContractNftAddressAddressUtxoGetRequest {
	return ApiContractNftAddressAddressUtxoGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
	}
}

/*
 * Execute executes the request
 * @return []ContractNftUtxo
 */
func (a *ContractApiService) ContractNftAddressAddressUtxoGetExecute(r ApiContractNftAddressAddressUtxoGetRequest) ([]ContractNftUtxo, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractNftUtxo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractNftAddressAddressUtxoGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/nft/address/{address}/utxo"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.codeHash != nil {
		localVarQueryParams.Add("codeHash", parameterToString(*r.codeHash, ""))
	}
	if r.genesis != nil {
		localVarQueryParams.Add("genesis", parameterToString(*r.genesis, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.flag != nil {
		localVarQueryParams.Add("flag", parameterToString(*r.flag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractNftGenesisCodeHashGenesisSummaryGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	codeHash   string
	genesis    string
}

func (r ApiContractNftGenesisCodeHashGenesisSummaryGetRequest) Execute() ([]ContractNftGenesisSummary, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractNftGenesisCodeHashGenesisSummaryGetExecute(r)
}

/*
 * ContractNftGenesisCodeHashGenesisSummaryGet Get nft summary(count group by address) for specific codeHash and genesisId(result cached for 60s).
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param codeHash Code hash of the token.
 * @param genesis Contract genesis
 * @return ApiContractNftGenesisCodeHashGenesisSummaryGetRequest
 */
func (a *ContractApiService) ContractNftGenesisCodeHashGenesisSummaryGet(ctx _context.Context, codeHash string, genesis string) ApiContractNftGenesisCodeHashGenesisSummaryGetRequest {
	return ApiContractNftGenesisCodeHashGenesisSummaryGetRequest{
		ApiService: a,
		ctx:        ctx,
		codeHash:   codeHash,
		genesis:    genesis,
	}
}

/*
 * Execute executes the request
 * @return []ContractNftGenesisSummary
 */
func (a *ContractApiService) ContractNftGenesisCodeHashGenesisSummaryGetExecute(r ApiContractNftGenesisCodeHashGenesisSummaryGetRequest) ([]ContractNftGenesisSummary, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractNftGenesisSummary
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractNftGenesisCodeHashGenesisSummaryGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/nft/genesis/{codeHash}/{genesis}/summary"
	localVarPath = strings.Replace(localVarPath, "{"+"codeHash"+"}", _neturl.PathEscape(parameterToString(r.codeHash, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"genesis"+"}", _neturl.PathEscape(parameterToString(r.genesis, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractNftGenesisCodeHashGenesisUtxoGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	codeHash   string
	genesis    string
	tokenIndex *int64
	max        *int64
	min        *int64
}

func (r ApiContractNftGenesisCodeHashGenesisUtxoGetRequest) TokenIndex(tokenIndex int64) ApiContractNftGenesisCodeHashGenesisUtxoGetRequest {
	r.tokenIndex = &tokenIndex
	return r
}
func (r ApiContractNftGenesisCodeHashGenesisUtxoGetRequest) Max(max int64) ApiContractNftGenesisCodeHashGenesisUtxoGetRequest {
	r.max = &max
	return r
}
func (r ApiContractNftGenesisCodeHashGenesisUtxoGetRequest) Min(min int64) ApiContractNftGenesisCodeHashGenesisUtxoGetRequest {
	r.min = &min
	return r
}

func (r ApiContractNftGenesisCodeHashGenesisUtxoGetRequest) Execute() ([]ContractNftUtxo, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractNftGenesisCodeHashGenesisUtxoGetExecute(r)
}

/*
 * ContractNftGenesisCodeHashGenesisUtxoGet Get all contract nft token utxos by codeHash and genesisId.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param codeHash Code hash of the token.
 * @param genesis Contract genesis
 * @return ApiContractNftGenesisCodeHashGenesisUtxoGetRequest
 */
func (a *ContractApiService) ContractNftGenesisCodeHashGenesisUtxoGet(ctx _context.Context, codeHash string, genesis string) ApiContractNftGenesisCodeHashGenesisUtxoGetRequest {
	return ApiContractNftGenesisCodeHashGenesisUtxoGetRequest{
		ApiService: a,
		ctx:        ctx,
		codeHash:   codeHash,
		genesis:    genesis,
	}
}

/*
 * Execute executes the request
 * @return []ContractNftUtxo
 */
func (a *ContractApiService) ContractNftGenesisCodeHashGenesisUtxoGetExecute(r ApiContractNftGenesisCodeHashGenesisUtxoGetRequest) ([]ContractNftUtxo, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractNftUtxo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractNftGenesisCodeHashGenesisUtxoGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/nft/genesis/{codeHash}/{genesis}/utxo"
	localVarPath = strings.Replace(localVarPath, "{"+"codeHash"+"}", _neturl.PathEscape(parameterToString(r.codeHash, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"genesis"+"}", _neturl.PathEscape(parameterToString(r.genesis, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.tokenIndex != nil {
		localVarQueryParams.Add("tokenIndex", parameterToString(*r.tokenIndex, ""))
	}
	if r.max != nil {
		localVarQueryParams.Add("max", parameterToString(*r.max, ""))
	}
	if r.min != nil {
		localVarQueryParams.Add("min", parameterToString(*r.min, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractNftSellAddressAddressUtxoGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	address    string
	codeHash   *string
	genesis    *string
	flag       *string
}

func (r ApiContractNftSellAddressAddressUtxoGetRequest) CodeHash(codeHash string) ApiContractNftSellAddressAddressUtxoGetRequest {
	r.codeHash = &codeHash
	return r
}
func (r ApiContractNftSellAddressAddressUtxoGetRequest) Genesis(genesis string) ApiContractNftSellAddressAddressUtxoGetRequest {
	r.genesis = &genesis
	return r
}
func (r ApiContractNftSellAddressAddressUtxoGetRequest) Flag(flag string) ApiContractNftSellAddressAddressUtxoGetRequest {
	r.flag = &flag
	return r
}

func (r ApiContractNftSellAddressAddressUtxoGetRequest) Execute() ([]ContractNftSellUtxo, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractNftSellAddressAddressUtxoGetExecute(r)
}

/*
 * ContractNftSellAddressAddressUtxoGet Get all contract sell sell utxos for specific address.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param address Owner address.
 * @return ApiContractNftSellAddressAddressUtxoGetRequest
 */
func (a *ContractApiService) ContractNftSellAddressAddressUtxoGet(ctx _context.Context, address string) ApiContractNftSellAddressAddressUtxoGetRequest {
	return ApiContractNftSellAddressAddressUtxoGetRequest{
		ApiService: a,
		ctx:        ctx,
		address:    address,
	}
}

/*
 * Execute executes the request
 * @return []ContractNftSellUtxo
 */
func (a *ContractApiService) ContractNftSellAddressAddressUtxoGetExecute(r ApiContractNftSellAddressAddressUtxoGetRequest) ([]ContractNftSellUtxo, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractNftSellUtxo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractNftSellAddressAddressUtxoGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/nft/sell/address/{address}/utxo"
	localVarPath = strings.Replace(localVarPath, "{"+"address"+"}", _neturl.PathEscape(parameterToString(r.address, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.codeHash != nil {
		localVarQueryParams.Add("codeHash", parameterToString(*r.codeHash, ""))
	}
	if r.genesis != nil {
		localVarQueryParams.Add("genesis", parameterToString(*r.genesis, ""))
	}
	if r.flag != nil {
		localVarQueryParams.Add("flag", parameterToString(*r.flag, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	codeHash   string
	genesis    string
	tokenIndex *int64
	max        *int64
	min        *int64
}

func (r ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest) TokenIndex(tokenIndex int64) ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest {
	r.tokenIndex = &tokenIndex
	return r
}
func (r ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest) Max(max int64) ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest {
	r.max = &max
	return r
}
func (r ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest) Min(min int64) ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest {
	r.min = &min
	return r
}

func (r ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest) Execute() ([]ContractNftSellUtxo, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractNftSellGenesisCodeHashGenesisUtxoGetExecute(r)
}

/*
 * ContractNftSellGenesisCodeHashGenesisUtxoGet Get all contract nft token utxos by codeHash and genesisId.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param codeHash Code hash of the token.
 * @param genesis Contract genesis
 * @return ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest
 */
func (a *ContractApiService) ContractNftSellGenesisCodeHashGenesisUtxoGet(ctx _context.Context, codeHash string, genesis string) ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest {
	return ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest{
		ApiService: a,
		ctx:        ctx,
		codeHash:   codeHash,
		genesis:    genesis,
	}
}

/*
 * Execute executes the request
 * @return []ContractNftSellUtxo
 */
func (a *ContractApiService) ContractNftSellGenesisCodeHashGenesisUtxoGetExecute(r ApiContractNftSellGenesisCodeHashGenesisUtxoGetRequest) ([]ContractNftSellUtxo, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractNftSellUtxo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractNftSellGenesisCodeHashGenesisUtxoGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/nft/sell/genesis/{codeHash}/{genesis}/utxo"
	localVarPath = strings.Replace(localVarPath, "{"+"codeHash"+"}", _neturl.PathEscape(parameterToString(r.codeHash, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"genesis"+"}", _neturl.PathEscape(parameterToString(r.genesis, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.tokenIndex != nil {
		localVarQueryParams.Add("tokenIndex", parameterToString(*r.tokenIndex, ""))
	}
	if r.max != nil {
		localVarQueryParams.Add("max", parameterToString(*r.max, ""))
	}
	if r.min != nil {
		localVarQueryParams.Add("min", parameterToString(*r.min, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}

type ApiContractUniqueGenesisCodeHashGenesisUtxoGetRequest struct {
	ctx        _context.Context
	ApiService *ContractApiService
	codeHash   string
	genesis    string
}

func (r ApiContractUniqueGenesisCodeHashGenesisUtxoGetRequest) Execute() ([]ContractUniqueUtxo, *_nethttp.Response, GenericOpenAPIError) {
	return r.ApiService.ContractUniqueGenesisCodeHashGenesisUtxoGetExecute(r)
}

/*
 * ContractUniqueGenesisCodeHashGenesisUtxoGet Get contract unique utxos by codeHash and genesisId.
 * @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param codeHash Code hash of the token.
 * @param genesis Contract genesis
 * @return ApiContractUniqueGenesisCodeHashGenesisUtxoGetRequest
 */
func (a *ContractApiService) ContractUniqueGenesisCodeHashGenesisUtxoGet(ctx _context.Context, codeHash string, genesis string) ApiContractUniqueGenesisCodeHashGenesisUtxoGetRequest {
	return ApiContractUniqueGenesisCodeHashGenesisUtxoGetRequest{
		ApiService: a,
		ctx:        ctx,
		codeHash:   codeHash,
		genesis:    genesis,
	}
}

/*
 * Execute executes the request
 * @return []ContractUniqueUtxo
 */
func (a *ContractApiService) ContractUniqueGenesisCodeHashGenesisUtxoGetExecute(r ApiContractUniqueGenesisCodeHashGenesisUtxoGetRequest) ([]ContractUniqueUtxo, *_nethttp.Response, GenericOpenAPIError) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		executionError       GenericOpenAPIError
		localVarReturnValue  []ContractUniqueUtxo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ContractApiService.ContractUniqueGenesisCodeHashGenesisUtxoGet")
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarPath := localBasePath + "/contract/unique/genesis/{codeHash}/{genesis}/utxo"
	localVarPath = strings.Replace(localVarPath, "{"+"codeHash"+"}", _neturl.PathEscape(parameterToString(r.codeHash, "")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"genesis"+"}", _neturl.PathEscape(parameterToString(r.genesis, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, nil, executionError
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		executionError.error = err.Error()
		return localVarReturnValue, localVarHTTPResponse, executionError
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v []ErrorResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, executionError
}
